(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{331:function(v,_,t){"use strict";t.r(_);var s=t(1),n=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("div",{staticClass:"content"},[t("p",[v._v("本章节主要说说业务的背景及所面临的问题")]),v._v(" "),t("h2",{attrs:{id:"业务背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#业务背景","aria-hidden":"true"}},[v._v("#")]),v._v(" 业务背景")]),v._v(" "),t("p",[v._v("收付费系统是保险核心业务系统中的一个重要模块，系统主要用户是公司财务部门。财务人员通过该系统进行收保费、付赔款、付手续费等业务流程的审核及确认，并留存凭证。实现了保险业务语言（如保费、赔款、手续费等）转变成会计语言（资产负债损益科目等）的过程。")]),v._v(" "),t("p",[v._v("任何企业都不可能离开财务，财务盈利甚至可以理解为企业最重要的目标。因企业活动（业务、运营、投资等）而产生的支出与收入必须用科学的方法进行统计，将其作为企业生存状态的一系列重要指标、决策层制定计划的重要参数。在之前，笔者单纯的以为财务只是记账而已，能把数算明白就行了。而在承担这份工作之后，才知道“记账”竟如此复杂。会计学，作为一门独立的科学，其深奥程度远超我的理解，但借助收付费系统，我得以瞥见其庞大知识体系的一隅。在实际的设计与开发工作中，需要对复式记账法有基本的理解，对常见的会计科目的意义及科目与科目之间的关系熟记于心。详细财务领域的知识，在此就不做过多阐述了")]),v._v(" "),t("p",[v._v("收付费系统功能大致可以归纳为：")]),v._v(" "),t("ul",[t("li",[v._v("保费、赔款、手续费等的挂账处理，生成挂账凭证；")]),v._v(" "),t("li",[v._v("保费、赔款、手续费等的结算处理，生成结算凭证；")]),v._v(" "),t("li",[v._v("部分业务处理要与监管部门做数据对接；")]),v._v(" "),t("li",[v._v("部分业务（如赔款），在确认支付之后，后台实时的转账付款操作；")]),v._v(" "),t("li",[v._v("以财务统计口径的月结工作，并生成相应报表；")]),v._v(" "),t("li",[v._v("发票管理与开具；")]),v._v(" "),t("li",[v._v("按照所属分公司及岗位的财务人员权限管理；")])]),v._v(" "),t("p",[v._v("具体功能，会在后续内容中详细说明。")]),v._v(" "),t("h2",{attrs:{id:"现行系统状况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#现行系统状况","aria-hidden":"true"}},[v._v("#")]),v._v(" 现行系统状况")]),v._v(" "),t("p",[v._v("现行系统是供应商采购的保险行业解决方案的一部分，使用JDK1.5，weblogic中间件，表现层使用Struts，没有明确意义上的业务层，持久层是使用原生jdbc的DAO，oracle数据库，批处理使用pl/sql脚本。是比较典型的单机应用，诞生时间不可考，可能诞生之时，spring还未普及，所以没有使用比较普遍的ssh或者ssm组合。在代码的注释中可以看到，有很多个团队维护过这套系统，所以代码层次比较混乱，coding风格五花八门。但可能是财务类系统的关系，对准确性要求比较高，在笔者接手这套系统时，系统并没有明显bug，还算稳定。")]),v._v(" "),t("p",[v._v("从这套系统底层的封装来看，当时的设计人员，对保险、财务领域非常精通，一些业务逻辑设计的非常巧妙，可见功底。抛开使用的技术不谈，只看业务设计的话，还是可圈可点的。其实上述“层次混乱”、没有统一coding风格的问题，在国内任何一个维护超过3年以上的系统中都非常普遍，何况这套系统已经诞生了近十年，所以这谈不上缺点。")]),v._v(" "),t("p",[v._v("而真正的缺点，在于它的扩展能力，毕竟十余年的时间过去了，生产力已经发生了翻天覆地的变化，企业对自动化、业务吞吐的能力、时效性的要求变得更高。服务器的宕机，会使企业业务中断，缓慢的处理速度会拖累业务的开展。这是这套系统所面临的最大的问题。")]),v._v(" "),t("p",[v._v("综上所述，所需要解决的问题，有以下几点：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("单机应用的通病，局部异常可能会导致整个服务瘫痪。")])]),v._v(" "),t("p",[v._v("某块业务逻辑设计不好导致内存溢出，系统崩溃，不可用；")]),v._v(" "),t("p",[v._v("网络链路中某一处的中断，导致系统不可用；")]),v._v(" "),t("p",[v._v("数据库宕机，导致系统不可用；")]),v._v(" "),t("p",[v._v("硬件资源使用到达上限，导致系统不可用；")]),v._v(" "),t("p",[v._v("数据库关键表死锁，导致系统不可用；")]),v._v(" "),t("p",[v._v("大量业务处理的堆积，同步的等待，导致系统不可用；")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("业务吞吐量增大了两个数量级。")]),v._v("\n原本每天批处理要处理1000单业务，现在需要处理10万，可用资源无法横向扩展，单纯的加内存这种纵向扩展方式可能满足需求，但不能明显缩减所需的时间。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("代码耦合。")]),v._v("\n这一点其实并不影响正常的业务，但对于系统开发人员来说，这是难以容忍的，它尤其对后来人非常不友好，代码越来越乱，需要改的地方越来越多，越晚接盘的人越痛苦。相信很多人有过同样的经历，一个简单需求的变更，在代码中都可能会掀起惊天骇浪。每个人都想写出优秀的代码，有设计模式、有美学的代码，然而在短暂的工期面前，可能都是幻想，逐渐的就会形成将错就错的恶性循环，而这种恶性循环其实从这个系统诞生的时候就已经注定了。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("被JSP支配的恐惧。")]),v._v("\nJSP这门技术对很多新入行的朋友来说，跟Struts一样陌生，可能会问：“世界上为什么要有这样的东西？” ，就像笔者不了解EJB存在的意义一样，但任何一门曾经流行过的技术都有它所依赖的时代背景。曾经，用JSP开发是非常方便的，可以活用的标签库，直接用java写业务逻辑，开发效率非常之高。然而，当系统成一定规模，它给开发者所带来的方便，会变成灾难。经历很多个维护团队之后，codestyle早已抛诸脑后，面对一个4000多行的jsp，java、js、html混在一起，逻辑代码里生成画面元素、js脚本里有逻辑代码，甚至有的开发人员因为某句js语法不熟悉而直接就写java......")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("数据库体量成倍增大，部分业务功能性能堪忧。")]),v._v("\n当前总公司、分公司所有业务数据都存在一个数据库实体中，一个表中百万数据非常常见，对sql的性能要求就越来越高，当前勉强可以应对，但终归会遇到性能瓶颈。")])]),v._v(" "),t("li",[t("p",[v._v("......")])])]),v._v(" "),t("h2",{attrs:{id:"微服务架构的可行性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微服务架构的可行性","aria-hidden":"true"}},[v._v("#")]),v._v(" 微服务架构的可行性")]),v._v(" "),t("p",[v._v("从过往的学习当中，可以简单的预研一下，这些问题如何解决，以及为了解决这些问题，会带来哪些新问题。")]),v._v(" "),t("p",[v._v("对于单机应用的共性问题，我们可以采用分布式、集群化实现高可用；\n对于吞吐量的问题，我们可以以微服务的方式架构，对于需要提高吞吐的服务通过增加集群成员，以横向提高其处理能力；\n对于代码耦合的问题，引入spring体系后会有明显的改善（当然，任何一个框架都不能完全约束开发人员，更主要的是统一的代码风格和基本功）；\nJSP的问题我们采用前后端分离，将表现层与业务层分离出来，以ajax连接；")]),v._v(" "),t("p",[v._v("数据库体量问题，首先可以考虑采用分库分表，读写分离的设计方式提高性能。\n上文提到现行系统所有分公司的数据都在一个库里。这里引申探讨一下。")]),v._v(" "),t("p",[v._v("保险公司会有总公司以及分支机构，而分支机构之间是独立运营的，比如北京分公司不应该参与到上海分公司的业务当中，深圳分公司也不应该看到广州分公司的数据。为了实现这种数据隔离的目的，有以下几种方案：")]),v._v(" "),t("p",[v._v("1."),t("strong",[v._v("应用和数据都不分离：")]),v._v(" 和现行系统一样，都放一起，在代码中以公司code加以区分限制，防止数据泄露；")]),v._v(" "),t("p",[v._v("2."),t("strong",[v._v("应用不分离、数据分离：")]),v._v(" 同一套应用，多数据源，以多租户的形式为分公司提供服务；")]),v._v(" "),t("p",[v._v("3."),t("strong",[v._v("应用数据都分离")]),v._v("：为每一个分公司都部署一套独立的系统；")]),v._v(" "),t("p",[v._v("第一种，缺陷上文已经说了；而第三种方案当然是最好的，但过于激进了，本身一套微服务架构系统就已经很复杂，把这个复杂程度乘以N倍，运维成本太高了。\n我们会选择第二种，即多租户的方案。多租户，即动态数据源技术，是指每个分公司有独立的数据库，前端发来的请求会带着租户（分公司ID）信息，后台按照租户信息来切换数据源，以查询不同的数据库。这么做不但降低了单个数据表的体量，而且各分公司数据库隔绝，只要控制好数据源的切换，就不存在数据泄露的问题。当然，这么做也有弊端。弊端一，因为有的需求是需要各分公司的汇总数据，这使得我们需要添加一些批处理，将所需要的分公司数据汇总至总公司库里；弊端二，微服务的架构中，服务之间的数据库也是分离的，这使得我们每个服务都要对应多个数据源。个人感觉，还是是利大于弊的，因为我们一再强调数据隔离的问题，多租户技术在解决这个问题上，是非常好的设计思路，至于其引入的复杂程度及其所带来的价值是需要进行衡量比较的，微服务架构没有一定之规，满足业务当前需求并具备一定的扩展能力是最根本的出发点。")]),v._v(" "),t("p",[v._v("另一个非常值得关注的点，就是收付费系统其实非常的适合做成微服务架构。\n虽然它所涉及的财务专业知识比较难懂，但业务流程非常简单，对于像收保费、付赔款、结算手续费、共保结算这类的业务操作，虽然业务场景不同，但做的是同一件事，就是结算，而且大致流程基本相似：选择业务、生成结算单、输入银行账号、结账或者付款。我们只需把结算这件事抽象好就可以了，对于不同的业务场景，彼此之间独立性也很强，每个业务场景可以封装成一个服务，这就形成了我们微服务架构的基本脉络：业务模块->结算模块（在后文中可以看到我们把这个结算模块称之为凭证模块，因为它不仅仅负责结算，还负责挂账、红冲等凭证相关的操作）。")]),v._v(" "),t("p",[v._v("我们再说一说微服务-分布式架构所带来的问题。")]),v._v(" "),t("p",[v._v("伴随微服务而来的最大的一个问题，就是系统组成变得异常复杂，运维难度增加。原先只需要监控一两台服务器就可以了，在微服务之后，我们需要盯着庞大系统中每一个组件的健康。而且它们需要容错能力，以防止雪崩的发生，如果某一个服务不可用导致整体系统都不可用，那我们做的所有努力都是无用功。")]),v._v(" "),t("p",[v._v("另外一个头疼的问题，分布式事务。在现行系统中，并没有对事务进行封装，每一次的DB操作，都需要开发人员手写开关事务。虽然代码丑陋，但对事务的操作尽在掌控。然而在进程间通信的微服务架构中，不同服务之间的事务必然是隔离的，需要引入分布式事务的解决方案，这也极大的增加了系统的复杂程度。")]),v._v(" "),t("p",[v._v("而第三个问题，对于开发团队，需要更多的技术储备。从现在的发展趋势来看，需要更多的全栈人员，以适应各种开发需要。")]),v._v(" "),t("p",[v._v("笔者对于这种传统行业与微服务的结合，并无经验，只能结合自己对收付费系统的业务理解以及进一步的学习，不断的摸索。本系列文章只从技术角度探索其可行性并加以实践，对于是否可以真正应用到生产，涉及诸多非技术因素，并非本文所讨论的范畴。")])])}],!1,null,null,null);_.default=n.exports}}]);